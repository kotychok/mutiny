#!/usr/bin/env ruby

require "base64"
require "fileutils"
require "tempfile"

# Create directory to store images if it does not already exist.
FileUtils.mkdir_p "README"

# Delete any previously exported files
Dir["./README/**/*"].each do |file|
  FileUtils.rm file
end

PROFILE = "fq0yteia.default"

## Create a file to cache session in so we don't have to fetch it every time
## this script runs
##
## If the file is not present or the cookie is expired, refetch (this will
## require closing firefox)
SESSION_CACHE_FILE = ".session-cache"

def generate_session_cache_file
  command = %(sqlite3 -line ~/.mozilla/firefox/#{PROFILE}/cookies.sqlite "SELECT value, expiry FROM moz_cookies WHERE name = 'bookstack_session';" | sed -s 's/ //g')
  contents = `#{command}`
  File.write SESSION_CACHE_FILE, contents
  puts "Wrote new session cache file"
end

if File.exist? SESSION_CACHE_FILE
  puts "Found .session-cache"
  expiry = `grep expiry < #{SESSION_CACHE_FILE} | cut -d'=' -f2`.to_i
  if expiry < Time.now.to_i
    puts "Cookie is expired, attempting to fetch new one"
    generate_session_cache_file
  else
    puts "Cookie is valid"
  end
else
  puts "Missing .session-cache. Attempting to fetch new one"
  generate_session_cache_file
end

# Fetch the post
# In order to read from the cookie database, firefox will have to be closed
# (this will also ensure current value is flushed to db)
SESSION = `grep value < .session-cache | cut -d'=' -f2`.strip
command = %(curl 'http://localhost:8080/books/projects/page/creating-a-voxel-engine-from-scratch/export/html' --silent -H "Cookie: bookstack_session=#{SESSION}")
html = `#{command}`

# Extract the images
IMAGE_URL_REGEX = /(http:\/\/localhost:8080)?\/uploads\/images\/gallery\/\d{4}-\d{2}-\w{3}\/[a-zA-Z0-9_\-.]+/
IMAGE_NAME_REGEX = /(http:\/\/localhost:8080)?\/uploads\/images\/gallery\/\d{4}-\d{2}-\w{3}\/\K[a-zA-Z0-9_\-.]+/

DATA_REGEX = /data:image\/[^;]*;base64,[a-zA-Z0-9+\/=]*/
BASE64_REGEX = /data:image\/[^;]*;base64,\K[a-zA-Z0-9+\/=]*/

new_html = html.split("\n").map { |html_line|
  image_match = html_line.match(IMAGE_NAME_REGEX)
  if image_match
    puts ""

    image_name = image_match[0]
    puts "Found image #{image_name}"

    base64_match = html_line.match(BASE64_REGEX)
    raise "Found bookstack image but no base64" unless base64_match
    base64 = base64_match[0]

    local_image_path = "./README/#{image_name}"
    puts "Local image path: #{local_image_path}"

    IO.write local_image_path, Base64.decode64(base64)

    new_html_line = html_line
      .sub(IMAGE_URL_REGEX, local_image_path)
      .sub(DATA_REGEX, local_image_path)

    new_html_line
  else
    html_line
  end
}.join("\n")

Tempfile.create do |html_file|
  File.write html_file.path, new_html

  Tempfile.create do |readme_file|
    # Convert html file to github markdown
    # Remove the automatically included final section which contains metadata
    puts "\nConverting html to markdown"
    command = "reverse_markdown #{html_file.path} --github-flavored=true | tac | sed '0,/* * */d' | tac"
    readme_contents = `#{command}`.strip
    File.write readme_file.path, readme_contents

    # Add in other project information.
    puts "\nAdding more project information to the README"
    readme_contents = readme_contents.prepend <<~MARKDOWN
      # Project structure

      README - Contains images for README.md
      assets - Contains textures
      bin - Contains misc binary files. Current ones are both used to generate README.md
      include - Third party header files
      src - My application source code
      test - My C++ application test code (what little of it exists)
      third_party_src - Source code for third party libraries to compile
      vendor - Compiled archive (.a) files
      vendor_src - Source code for vendor libraries

      I feel like there's some better way to organize ./include,
      ./third_party_src, and ./vendor_src, but I'm not sure how.\n
    MARKDOWN
    File.write readme_file.path, readme_contents

    # Add in a table of contents
    puts "\nInserting table of contents (this may take a while, ~30s)"
    command = "cat #{readme_file.path} | ./bin/gh-md-toc - | sed 's/^[	 ]*//'"
    table_of_contents = `#{command}`.strip
    readme_contents = readme_contents.prepend "**Table of Contents**\n\n" + table_of_contents + "\n\n"

    # Write README contents to file.
    File.write "README.md", readme_contents
  end
end
